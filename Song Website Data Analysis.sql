--1. We want to get the information of the artists from the two table to know the most famous one according to the number of users hear their songs--
SELECT E.ARTIST_ID, ARTIST_LOCATION, ARTIST_LATITUDE, ARTIST_LONGITUDE, COUNT(E.USER_ID) OVER(PARTITION BY E.ARTIST_NAME) USERS_NUMBER
FROM EVENTS E, SONGS S
WHERE E.ARTIST_NAME = S.ARTIST_NAME

--2. We want to order them, and get rid of duplicates by this--
SELECT DISTINCT * FROM
(SELECT E.ARTIST_ID, ARTIST_LOCATION, ARTIST_LATITUDE, ARTIST_LONGITUDE, COUNT(E.USER_ID) OVER(PARTITION BY E.ARTIST_NAME) USERS_NUMBER
FROM EVENTS E, SONGS S
WHERE E.ARTIST_NAME = S.ARTIST_NAME) USER_SUB_Q
ORDER BY USERS_NUMBER DESC;


--3. We want to know famous songs and some other information by joining the two tables--
SELECT * FROM
(SELECT SONG_ID, S.SONG_NAME, S.ARTIST_ID, E_ARTIST_NAME, E.SONG_LENGTH_IN_SECONDS, COUNT(USER_ID) OVER(PARTITION BY SONG_ID) USERS_NUMBER
FROM EVENTS E, SONGS S
WHERE E.SONG_NAME = S.SONG_NAME AND SONG_PLAYED = 'NextSong')
SUB_QUERY ORDER BY USERS_NUMBER DESC;

--4. We want to know the most played songs in all sessions in events table so we can get some offers and promotions to users and information of each song--
SELECT DISTINCT SONG_NAME, ARTIST_NAME, SONG_LEVEL, COUNT(USER_ID) OVER (PARTITION BY SONG_NAME) USERS_NUMBER
FROM EVENTS
WHERE SONG_PLAYED = 'NextSong'

--5. We get the rank of each song with dense rank and subquery--
SELECT *, DENSE_RANK() OVER(ORDER BY USERS_NUMBER DESC) FROM
(SELECT DISTINCT SONG_NAME, ARTIST_NAME, SONG_LEVEL, COUNT(USER_ID) OVER (PARTITION BY SONG_NAME) USERS_NUMBER
FROM EVENTS
WHERE SONG_PLAYED = 'NextSong') SUB_QUERY_1
WHERE SONG_NAME IS NOT NULL;

--6. We want to know the most famous song with the session distribution among users--
SELECT SESSION_ID, SONG_NAME, COUNT(USER_ID) OVER(PARTITION BY SESSION_ID, SONG_NAME) USERS_NUMBER, ARTIST_NAME, SONG_LEVEL
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong'

--7. Get the rank of each song in each partition--
SELECT DISTINCT SESSION_ID, SONG_NAME, USERS_NUMBER, ARTIST_NAME, SONG_LEVEL, DENSE_RANK() OVER(PARTITION BY SESSION_ID ORDER BY USERS_NUMBER DESC) SONG_RANK FROM
(SELECT SESSION_ID, SONG_NAME, COUNT(USER_ID) OVER(PARTITION BY SESSION_ID, SONG_NAME) USERS_NUMBER, ARTIST_NAME, SONG_LEVEL
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong') SUB_QUERY

--8. Group all the information by selected columns and order them by session number and rank number--
SELECT * FROM (
SELECT DISTINCT SESSION_ID, SONG_NAME, USERS_NUMBER, ARTIST_NAME, SONG_LEVEL, DENSE_RANK() OVER(PARTITION BY SESSION_ID ORDER BY USERS_NUMBER DESC) SONG_RANK FROM
(SELECT SESSION_ID, SONG_NAME, COUNT(USER_ID) OVER(PARTITION BY SESSION_ID, SONG_NAME) USERS_NUMBER, ARTIST_NAME, SONG_LEVEL
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong') SUB_QUERY) SUB_QUERY_2
GROUP BY SESSION_ID, SONG_NAME, SONG_LEVEL, USERS_NUMBER, ARTIST_NAME, SONG_RANK
ORDER BY SESSION_D, SONG_RANK;

--9. Get the artist information and count of songs--
SELECT DISTINCT ARTIST_NAME, SONG_NAME, COUNT(SONG_NAME) OVER(PARTITION BY ARTIST_NAME) SONGS_NUMBER
FROM EVENTS
WHERE SONG_NAME IS NOT NULL

--10. Rank each artist according to the number of users and sort them in descending order--
SELECT *, DENSE_RANK() OVER(ORDER BY SONGS_NUMBER DESC) FROM
(SELECT DISTINCT ARTIST_NAME, SONG_NAME, COUNT(SONG_NAME) OVER(PARTITION BY ARTIST_NAME) SONGS_NUMBER
FROM EVENTS
WHERE SONG_NAME IS NOT NULL) SUB_QUERY;

--11. Get the most contributed users in the system--
SELECT DISTINCT SESSION_ID, USER_ID, USER_FIRST_NAME, USER_GENDER, USER_LAST_NAME, SONG_NAME,
COUNT(SONG_NAME) OVER (PARTITION BY USER_ID) SONGS_NUMBER
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong'

--12. Rank each user and order them in descending order according to the songs they hear--
SELECT *, DENSE_RANK() OVER(ORDER BY SONGS_NUMBER) USER_RANK FROM
(SELECT DISTINCT SESSION_ID, USER_ID, USER_FIRST_NAME, USER_GENDER, USER_LAST_NAME, SONG_NAME,
COUNT(SONG_NAME) OVER (PARTITION BY USER_ID) SONGS_NUMBER
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong') SUB_QUERY;

--13. Know the longest and shortest song the users heard in each session--
SELECT SONG_NAME, ARTIST_NAME, SESSION_ID, SONG_LENGTH_IN_SECONDS, USER_ID,
FIRST_VALUE(SONG_NAME) OVER(PARTITION BY SESSION_ID ORDER BY SONG_LENGTH_IN_SECONDS DESC) LONGEST_SONG,
FIRST_VALUE(SONG_NAME) OVER(PARTITION BY SESSION_ID ORDER BY SONG_LENGTH_IN_SEONDS) SHORTEST_SONG
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong'
ORDER BY SESSION_ID;

--14. Analysis the number of successful trais the users get to the website--
SELECT USER_ID, USER_FIRST_NAME, USER_LAST_NAME,
COUNT(USER_ID) OVER(PARTITION BY USER_ID) NUMBER_OF_TRILS,
COUNT (CASE WHEN SONG_STATUS = 200 THEN 1 END) OER(PARTITION BY USER_ID) SUCCESSFUL_TRAILS
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong'

--15. Calculate the percentage of successful connection to the website by successful trails by the number of trails--
SELECT DISTINCT USER_ID, USER_FIRST_NAME, USER_LAST_NAME, NUMBER_OF TRAILS, SUCCESSFUL_TRAILS,
CAST(SUCCESSFUL_TRAILS AS FLOAT) /NUMBER_OF_TRAILS SUCCESSFUL_PERCENTAGE FROM
(SELECT USER_ID, USER_FIRST_NAME, USER_LAST_NAME,
COUNT(USER_ID) OVER(PARTITION BY USER_ID) NUMBER_OF_TRILS,
COUNT (CASE WHEN SONG_STATUS = 200 THEN 1 END) OER(PARTITION BY USER_ID) SUCCESSFUL_TRAILS
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong') SUB_QUERY
ORDER BY USER_ID;

--16. Analysis the income channel as we can know the income from each user from the level of the song paid or free--
SELECT DISTINCT USER_ID, USER_FIRST_NAME, USER_LAST_NAME,
COUNT(CASE SONG_LEVEL WHEN 'paid' THEN 1 END) OVER(PARTITION BY USER_ID) PAID_SONGS_NUMBER,
COUNT(CASE SONG_LEVEL WHEN 'free' THEN 1 END) OER(PARTITION BY USER_ID) FREE_SONGS_NUMBER
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong'

--17. Calculate the percentage of the paid songs from the total and then order by the user id--
SELECT USER_ID, USER_FIRST_NAME, USER_LAST_NAME, PAID_SONGS_NUMBER, FREE_SONGS_NUMBER, FREE_SONGS_NUMBER,
CAST (PAID_SONGS_NUMBER AS FLOAT) / (PAID_SONGS_NUMBER + FREE_SONGS_NUMBER) PAID_SONGS_PERCENTAGE FROM
(SELECT DISTINCT USER_ID, USER_FIRST_NAME, USER_LAST_NAME,
COUNT(CASE SONG_LEVEL WHEN 'paid' THEN 1 END) OVER(PARTITION BY USER_ID) PAID_SONGS_NUMBER,
COUNT(CASE SONG_LEVEL WHEN 'free' THEN 1 END) OER(PARTITION BY USER_ID) FREE_SONGS_NUMBER
FROM EVENTS
WHERE SONG_NAME IS NOT NULL) SUB_QUERY
ORDER BY USER_ID;

--18. We need to know how long each user spent in the system website listening to songs and order the user to know--
SELECT DISTINCT USER_ID, USER_FIRST_NAME, USER_LAST_NAME,
SUM(SONG_LENGTH_IN_SECONDS) OVER(PARTITION BY USER_ID) USER_DURATION_IN_SECONDS
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong';

--19. How long each user spend in our web site--
SELECT USER_ID, DENSE_RANK() OVER(ORDER BY USER_DURATION_IN_SECONDS DESC),
USER_FIRST_NAME, USER_LAST_NAME, USER_DURATION_IN_SECONDS FROM
(SELECT DISTINCT USER_ID, USER_FIRST_NAME, USER_LAST_NAME,
SUM(SONG_LENGTH_IN_SECONDS) OVER(PARTITION BY USER_ID) USER_DURATION_IN_SECONDS
FROM EVENTS
WHERE SONG_NAME IS NOT NULL AND SONG_PLAYED = 'NextSong') SUB_QUERY;
